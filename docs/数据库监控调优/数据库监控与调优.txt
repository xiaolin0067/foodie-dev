数据库调优维度
  业务需求：勇敢地对不合理的需求说不
  系统架构：做架构设计的时候，应充分考虑业务的实际情况，考虑好数据库的各种选择(读写分离?高可用?实例个数?分库分表?用什么数据库?)
  SQL及索引：根据需求编写良好的SQL，并去创建足够高效的索引
  表结构：设计良好的表结构
  数据库参数设置：设置合理的数据库性能参数(join buffer、sort buffer...)
  系统配置：操作系统提供了各种资源使用策略，设置合理的配置，以便于数据库充分利用资源(swap应尽可能小 -> swappiness)
  硬件：SSD or 机械硬盘

mysql官方测试数据库
  https://dev.mysql.com/doc/index-other.html
  https://github.com/datacharmer/test_db

慢查询日志
  方式一、修改配置文件my.cnf，在[mysqld]段落中加入如上参数即可
    [mysqld]
    slow_query_log = ON
    log_output = 'FILE,TABLE'
    long_query_time = 2
    重启MySQL: service mysqld restart
  方式二、通过全局变量设置，这种方式无需重启即可生效，但一旦重启，配置又会丢失
    set global slow_query_log = 'ON';
    set global log_output = 'FILE,TABLE';
    # long_query_time需要切换session才能生效
    set global long_query_time = 2;
    将慢查询日志同时记录到文件以及mysql.slow_log表中
  查看慢查询记录
    查看TABLE记录：select * from mysql.slow_log;
    查看slow FILE文件：
    show variables like '%slow_query_log_file%';
    分析慢查询日志文件
      mysqldumpslow -s r -t 10 -a /var/lib/mysql/node3-26-slow.log
      pt-query-digest
SQL性能分析
  EXPLAIN
    explain extended select * from employees;
    可视化分析
      IDEA：Explain plan
      MysqlWorkBench
    show warnings;
  SHOW PROFILE: 简单、方便，已废弃
  INFORMATION_SCHEMA.PROFILING: 和SHOW PROFILE本质一样
  PERFORMANCE_SCHEMA: 未来之光，但目前来说使用不够方便
  OPTIMIZER_TRACE：跟踪优化器做出的各种决策、了解优化器的执行细节、理解SQL的执行过程，进而优化SQL

数据库诊断
  SHOW FULL PROCESSLIST; = SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST;
    按照客户端IP分组,看哪个客户端的连接数最多
    select client_ip, count(client_ip) as client_num from (select substring_index ( host, ':', 1 ) as client_ip from information_schema.processlist) as connect_info group by client_ip order by client_num desc;
    查看正在执行的线程，并按time倒排序，看看有没有执行时间特别长的线程
    select * from information_schema.processlist where command != 'sleep' order by Time desc;
    找出所有执行时间超过5分钟的线程，拼凑出kill语句，方便后面查杀
    select concat ('kill', id, ';') from information_schema.processlist where Command != 'Sleep' and Time > 300 order by Time desc;
  SHOW STATUS;
    show global status like '%slow%';
  SHOW VARIABLES;
    SHOW VARIABLES like '%%';
  SHOW TABLE STATUS;
  SHOW INDEX FROM EMPLOYEES;
  SHOW ENGINE INNODB STATUS\G
  SHOW MASTER STATUS;
  SHOW SLAVE STATUS;

B-Tree(B+Tree)索引
  特性，以下情况可以使用到索引：
    完全匹配: index(name) => where name = '大目'
    范围匹配: index(age) => where age > 5
    前缀匹配（即右模糊可以使用索引，左模糊不能使用索引）: 
      index(name) => where name like '大%'
  限制：
    对于组合索引需符合最左前缀原则，其索引列顺序很重要，对于不同的查询条件可对相同的索引列创建不同顺序的组合索引：index(name, age, sex)
      查询条件不包括最左列,无法使用索引
        where age=5 and sex=1 无法使用索弓
      跳过了索弓|中的列,则无法完全使用索引
        where name = '大目' and sex = 32 只能用name这一列的索引
	  查询中有某个列的范围(模糊)查询,则其右边所有列都无法使用索引
	    where name = '大目' and age > 32 and sex = 1 只能用name、age两列
Hash索引
  Memory引擎可手动指定Hash索引：create table test_hash_index(id bigint(20) not null, name varchar(45) not null, key using hash (name)) engine = memory;
  InnoDB引擎支持自适应Hash索引，InnoDB引擎发现某些值访问的非常频繁时会在内存里创建一个Hash索引。
    show variables like 'innodb_adaptive_hash_index';
    set global innodb_adaptive_hash_index = 'ON';
  特性：一般性能比B-Tree(B+Tree)要好一些，不产生Hash冲突事件复杂度为O(1)
  限制：
    Hash索索引并不是按照索引值排序，所以没法使用排序，order by
    不支持部分索引列匹配查找
      hash(a, b) => where a = 1
	只支持等值查询(例如=、IN)，不支持范围查询、模糊查询
	Hash冲突越严重,性能下降越厉害
创建索引的原则（原则只是参考，不要死守教条）
  建议创建索引的场景：
    1、select、update、delete语句的where条件字段，要符合最左原则
	2、需要分组、排序（group by, order by）的字段
	3、dintinct()的字段
	4、字段值有唯一性约束，创建唯一索引
	5、多表查询联结的字段应创建索引，且类型务必一致（避免隐式转换可能导致索引无法使用）
  不建议创建索引：
    1、where字句里用不到的字段
	2、表记录很少
	3、有大量重复数据，选择性低（索引的选择性越高,查询效率越好,因为可以在查找是过滤更多行）
	4、频繁更新的字段,如果创建索引要考虑其索引维护开销
	5、参与列计算的的列不适合添加索引
导致索引失效的场景:
  1.索引列不独立--独立是指：列不能是表达式的一部分，也不能是函数的参数
  2.使用了左模糊--避免左模糊'%xxx'，业务要求可使用搜索引擎
  3.使用0R查询的部分字段没有索引--or的所有字段都要有索引
  4.字符串条件未使用''引起来--传入索引列匹配类型必须一致
  5.不符合最左前缀原则的查询
      存在index(last_name, first_name)
        explain select * from employees where first_name = 'facello';
      解决方案: 调整索引的顺序，变成index(first_name, last_name)或者index(first_name)
  6.索引字段建议添加NOT NULL约束--将索引字段设置为not null并设置默认值
      单列索引无法储null值，复合索引无法储全为null的值
	  查询时，采用is null条件时，不能利用到索引，只能全表扫描
	  MySQL官方建议尽量把字段定义为NOT NULL，除非需求必要必要
  7.隐式转换导致索引失效--表联结查询的关联字段类型必须一致
索引调优技巧：
  非主键索引会记录主键
  1、长字段的索引调优
    ①给长字段的表额外增加一个hash列并将该列添加索引，insert时将长字段的hash结果存入该字段。
	    hash列应具备以下要求：[字段长度应该比较小，SHA1/MD5是不合适的]、[应尽量避免hash冲突，目前流行CRC32或者FNV64()]
		select * from employees where first_name = 'Facello';
		变更为：select * from employees where first_name_hash = CRC32('Facello') and first_name = 'Facello';
		缺点：不能解决模糊搜索（like）的问题
    ②前缀索引，可以让索引更小、对上层透明业务无需改造
	    alter table employees add key (first_name(7));
	    索引选择性 = 不重复的索引值 / 数据表的总记录数（数值越大，表示选择性越高，性能越好）
        计算完整列的选择性：select count(distinct first_name)/count(*) from employees;
		计算前缀索引不同前缀数的索引选择性，找到最合适的一个：
		    select count(distinct left(first_name, 7)) / count(*) from employees;
        “后缀索引”：额外创建一个字段，如first_name_reverse，将first_name逆序处理后存储，然后对first_name_reverse创建前缀索引
		缺点：无法做order by, group by; 无法使用覆盖索引
单列索引vs组合索引：
  SQL存在多个条件，多个单列索引，会使用索引合并(explain type = index_merge)
  如果出现索引合并，往往说明索引不够合理
  如果SQL暂时没有性能问题，暂时可以不管
  组合索引要注意索引列顺序[符合最左前缀原则]
覆盖索引：查询的字段就是索引字段
  尽量只返回想要的字段，使用覆盖索引，减少网络传输的开销
索引是有开销的：索引的增删改的维护开销，索引越多维护开销越大，所以在条件允许的情况下应该尽量少创建一些索引。
重复索引：在相同的列上按照相同的顺序创建的索引。
  create table test_table ( id int not null primary key auto_increment, b int not null, unique(id), index(id)) engine = InnoDB;
  尽量避免重复索引，如果发现重复索引应该删除。
冗余索引：如果已经存在索引index(A, B)，又创建了index(A)，那么index(A)就是index(A, B)的冗余索引
  一般来说应该删除，但存在特例，例如：explain select * from salaries where from_date = '1986-06-26' order by emp_no;
    index(from_date)：type=ref extra=null，使用了索引
    index(from_date)某种意义上来说就相当于index(from_date, emp_no)
    index(from_date, to_date)：type=ref extra=Using filesort, order by字句无法使用索引
    index(from_date, to_date)某种意义上来说就相当于index(from_date, to_date, emp_no)
未使用的索引：累赘，删除
JOIN语句优化：
  笛卡尔连接(cross join)
    select * from users a cross join orders b;
    如果cross join带有on子句，就相当于inner join
    seLect * from users a cross join orders b on a.id = b.user_ id;
  1、嵌套循环JOIN算法，Nested-Loop Join(NLU)
  2、块嵌套循环JOIN算法，Block Nested-Loop Join(BNLJ)
      通过引入join buffer从而在内存循环降低表的扫描次数，使用join buffer的条件：
	    1、连接类型是ALL、index或range
		2、第一个nonconst table（非常量表）不会分配join buffer ,即使类型是ALL或者index
      join buffer只会缓存需要的字段，而非整行数据
      可通过join_buffer_size变量设置join buffer的大小，一般全局采用默认值256k，可自定义当前session的size设置大一些
	    show variables like 'join_buffer_size';
        set [global] join_buffer_size = 1024*1024*50;
      每个能被缓存的join都会分配一个join buffer，一个查询可能拥有多个join buffer
	  join buffer在执行联接之前会分配，在查询完成后释放
      如何判断SQL使用了BNLJ？
	    explain select * from users a left join orders b on a.id = b.user_id;
		extra中出现了表示使用了BNLJ：Using join buffer (Block Nested Loop)
  3、批量键值访问算法，Batched Key Access Join(BKA)
	  MRR：将随机IO转换成顺序IO，从而提升性能，默认开启
	    背景：在非主键索引的范围查询条件下，可能会导致随机IO（数据实际存储是按照主键ID排列的，非主键索引过滤出来的数据主键ID顺序可能乱序，导致随机IO）
        optimizer_switch的子参数
		  mrr：是否开启mrr，on开启，off关闭
          mrr_cost_based：表示是否要开启基于成本计算的MRR
		read_rnd_buffer_size：指定mrr缓存大小，存放索引内存的大小
	  如何判断SQL使用了MRR？
	    # 基于成本的MRR默认很保守，关闭后MRR更容易被使用
        set optimizer_switch = 'mrr_cost_based=off;
		elplain中的extra包含Using MRR表示使用了MRR
	  BKA在MySQL5.6引入，BKA基石：Multi Range Read(MRR)
        BKA参数，optimizer_switch的子参数
	      batched_key_access：on开启，off关闭，默认关闭
	4、HASH JOIN，MySQL 8.0.18引入,用来替代BNLJ
	    https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html
        join buffer缓存外部循环的hash表，内层循环遍历时到hash表匹配
		MySQL8.0.18才引入，且有很多限制，比如不能作用于外连接，比如left join/right join等等
		从8.0.20开始限制少了很多，且废弃了BNLJ，建议用8.0.20或更高版本
		从MySQL 8.0.18开始，hash join的join buffer是递增分配的,这意味着，你可以为将join_buffer_size设置得比较大
		而在MySQL 8.0.18中如果你使用了外连接，外连接没法用hash join，此时join_buffer_size会按照你设置的值直接分配内存。因此join_buffer_size还是得谨慎设置




	  
































































