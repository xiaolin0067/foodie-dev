数据库调优维度
  业务需求：勇敢地对不合理的需求说不
  系统架构：做架构设计的时候，应充分考虑业务的实际情况，考虑好数据库的各种选择(读写分离?高可用?实例个数?分库分表?用什么数据库?)
  SQL及索引：根据需求编写良好的SQL，并去创建足够高效的索引
  表结构：设计良好的表结构
  数据库参数设置：设置合理的数据库性能参数(join buffer、sort buffer...)
  系统配置：操作系统提供了各种资源使用策略，设置合理的配置，以便于数据库充分利用资源(swap应尽可能小 -> swappiness)
  硬件：SSD or 机械硬盘

mysql官方测试数据库
  https://dev.mysql.com/doc/index-other.html
  https://github.com/datacharmer/test_db

查看所有查询日志，使用后立即关闭
  SET GLOBAL general_log = 'ON';
  SET GLOBAL general_log = 'OFF';
  show variables like '%general_log%';

慢查询日志
  方式一、修改配置文件my.cnf，在[mysqld]段落中加入如上参数即可
    [mysqld]
    slow_query_log = ON
    log_output = 'FILE,TABLE'
    long_query_time = 2
    重启MySQL: service mysqld restart
  方式二、通过全局变量设置，这种方式无需重启即可生效，但一旦重启，配置又会丢失
    set global slow_query_log = 'ON';
    set global log_output = 'FILE,TABLE';
    # long_query_time需要切换session才能生效
    set global long_query_time = 2;
    将慢查询日志同时记录到文件以及mysql.slow_log表中
  查看慢查询记录
    查看TABLE记录：select * from mysql.slow_log;
    查看slow FILE文件：
    show variables like '%slow_query_log_file%';
    分析慢查询日志文件
      mysqldumpslow -s r -t 10 -a /var/lib/mysql/node3-26-slow.log
      pt-query-digest
SQL性能分析
  EXPLAIN
    explain extended select * from employees;
	id越大越先执行，相同的id则上面的先执行
    可视化分析
      IDEA：Explain plan
      MysqlWorkBench
    show warnings;
  SHOW PROFILE: 简单、方便，已废弃
  INFORMATION_SCHEMA.PROFILING: 和SHOW PROFILE本质一样
  PERFORMANCE_SCHEMA: 未来之光，但目前来说使用不够方便
  OPTIMIZER_TRACE：跟踪优化器做出的各种决策、了解优化器的执行细节、理解SQL的执行过程，进而优化SQL

数据库诊断
  SHOW FULL PROCESSLIST; = SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST;
    按照客户端IP分组,看哪个客户端的连接数最多
    select client_ip, count(client_ip) as client_num from (select substring_index ( host, ':', 1 ) as client_ip from information_schema.processlist) as connect_info group by client_ip order by client_num desc;
    查看正在执行的线程，并按time倒排序，看看有没有执行时间特别长的线程
    select * from information_schema.processlist where command != 'sleep' order by Time desc;
    找出所有执行时间超过5分钟的线程，拼凑出kill语句，方便后面查杀
    select concat ('kill', id, ';') from information_schema.processlist where Command != 'Sleep' and Time > 300 order by Time desc;
  SHOW STATUS;
    show global status like '%slow%';
  SHOW VARIABLES;
    SHOW VARIABLES like '%%';
  SHOW TABLE STATUS;
  SHOW INDEX FROM EMPLOYEES;
  SHOW ENGINE INNODB STATUS\G
  SHOW MASTER STATUS;
  SHOW SLAVE STATUS;

B-Tree(B+Tree)索引
  特性，以下情况可以使用到索引：
    完全匹配: index(name) => where name = '大目'
    范围匹配: index(age) => where age > 5
    前缀匹配（即右模糊可以使用索引，左模糊不能使用索引）: 
      index(name) => where name like '大%'
  限制：
    对于组合索引需符合最左前缀原则，其索引列顺序很重要，对于不同的查询条件可对相同的索引列创建不同顺序的组合索引：index(name, age, sex)
      查询条件不包括最左列,无法使用索引
        where age=5 and sex=1 无法使用索弓
      跳过了索引中的列,则无法完全使用索引
        where name = '大目' and sex = 32 只能用name这一列的索引
	  查询中有某个列的范围(模糊)查询,则其右边所有列都无法使用索引
	    where name = '大目' and age > 32 and sex = 1 只能用name、age两列
Hash索引
  Memory引擎可手动指定Hash索引：create table test_hash_index(id bigint(20) not null, name varchar(45) not null, key using hash (name)) engine = memory;
  InnoDB引擎支持自适应Hash索引，InnoDB引擎发现某些值访问的非常频繁时会在内存里创建一个Hash索引。
    show variables like 'innodb_adaptive_hash_index';
    set global innodb_adaptive_hash_index = 'ON';
  特性：一般性能比B-Tree(B+Tree)要好一些，不产生Hash冲突事件复杂度为O(1)
  限制：
    Hash索索引并不是按照索引值排序，所以没法使用排序，order by
    不支持部分索引列匹配查找
      hash(a, b) => where a = 1
	只支持等值查询(例如=、IN)，不支持范围查询、模糊查询
	Hash冲突越严重,性能下降越厉害
创建索引的原则（原则只是参考，不要死守教条）
  建议创建索引的场景：
    1、select、update、delete语句的where条件字段，要符合最左原则
	2、需要分组、排序（group by, order by）的字段
	3、dintinct()的字段
	4、字段值有唯一性约束，创建唯一索引
	5、多表查询联结的字段应创建索引，且类型务必一致（避免隐式转换可能导致索引无法使用）
  不建议创建索引：
    1、where字句里用不到的字段
	2、表记录很少
	3、有大量重复数据，选择性低（索引的选择性越高,查询效率越好,因为可以在查找是过滤更多行）
	4、频繁更新的字段,如果创建索引要考虑其索引维护开销
	5、参与列计算的的列不适合添加索引
导致索引失效的场景:
  1.索引列不独立--独立是指：列不能是表达式的一部分，也不能是函数的参数
  2.使用了左模糊--避免左模糊'%xxx'，业务要求可使用搜索引擎
  3.使用OR查询的部分字段没有索引--or的所有字段都要有索引
  4.字符串条件未使用''引起来--传入索引列匹配类型必须一致
  5.不符合最左前缀原则的查询
      存在index(last_name, first_name)
        explain select * from employees where first_name = 'facello';
      解决方案: 调整索引的顺序，变成index(first_name, last_name)或者index(first_name)
  6.索引字段建议添加NOT NULL约束--将索引字段设置为not null并设置默认值
      单列索引无法储null值，复合索引无法储全为null的值
	  查询时，采用is null条件时，不能利用到索引，只能全表扫描
	  MySQL官方建议尽量把字段定义为NOT NULL，除非需求必要
  7.隐式转换导致索引失效--表联结查询的关联字段类型必须一致
索引调优技巧：
  非主键索引会记录主键
  1、长字段的索引调优
    ①给长字段的表额外增加一个hash列并将该列添加索引，insert时将长字段的hash结果存入该字段。
	    hash列应具备以下要求：[字段长度应该比较小，SHA1/MD5是不合适的]、[应尽量避免hash冲突，目前流行CRC32或者FNV64()]
		select * from employees where first_name = 'Facello';
		变更为：select * from employees where first_name_hash = CRC32('Facello') and first_name = 'Facello';
		缺点：不能解决模糊搜索（like）的问题
    ②前缀索引，可以让索引更小、对上层透明业务无需改造
	    alter table employees add key (first_name(7));
	    索引选择性 = 不重复的索引值 / 数据表的总记录数（数值越大，表示选择性越高，性能越好）
        计算完整列的选择性：select count(distinct first_name)/count(*) from employees;
		计算前缀索引不同前缀数的索引选择性，找到最合适的一个：
		    select count(distinct left(first_name, 7)) / count(*) from employees;
        “后缀索引”：额外创建一个字段，如first_name_reverse，将first_name逆序处理后存储，然后对first_name_reverse创建前缀索引
		缺点：无法做order by, group by; 无法使用覆盖索引
单列索引vs组合索引：
  SQL存在多个条件，多个单列索引，会使用索引合并(explain type = index_merge)
  如果出现索引合并，往往说明索引不够合理
  如果SQL暂时没有性能问题，暂时可以不管
  组合索引要注意索引列顺序[符合最左前缀原则]
覆盖索引：查询的字段就是索引字段
  尽量只返回想要的字段，使用覆盖索引，减少网络传输的开销
索引是有开销的：索引的增删改的维护开销，索引越多维护开销越大，所以在条件允许的情况下应该尽量少创建一些索引。
重复索引：在相同的列上按照相同的顺序创建的索引。
  create table test_table ( id int not null primary key auto_increment, b int not null, unique(id), index(id)) engine = InnoDB;
  尽量避免重复索引，如果发现重复索引应该删除。
冗余索引：如果已经存在索引index(A, B)，又创建了index(A)，那么index(A)就是index(A, B)的冗余索引
  一般来说应该删除，但存在特例，例如：explain select * from salaries where from_date = '1986-06-26' order by emp_no;
    index(from_date)：type=ref extra=null，使用了索引
    index(from_date)某种意义上来说就相当于index(from_date, emp_no)
    index(from_date, to_date)：type=ref extra=Using filesort, order by字句无法使用索引
    index(from_date, to_date)某种意义上来说就相当于index(from_date, to_date, emp_no)
未使用的索引：累赘，删除
JOIN语句优化：
  笛卡尔连接(cross join)
    select * from users a cross join orders b;
    如果cross join带有on子句，就相当于inner join
    seLect * from users a cross join orders b on a.id = b.user_ id;
  1、嵌套循环JOIN算法，Nested-Loop Join(NLJ)
  2、块嵌套循环JOIN算法，Block Nested-Loop Join(BNLJ)
      通过引入join buffer从而在内存循环降低表的扫描次数，使用join buffer的条件：
	    1、连接类型是ALL、index或range
		2、第一个nonconst table（非常量表）不会分配join buffer ,即使类型是ALL或者index
      join buffer只会缓存需要的字段，而非整行数据
      可通过join_buffer_size变量设置join buffer的大小，一般全局采用默认值256k，可自定义当前session的size设置大一些
	    show variables like 'join_buffer_size';
        set [global] join_buffer_size = 1024*1024*50;
      每个能被缓存的join都会分配一个join buffer，一个查询可能拥有多个join buffer
	  join buffer在执行联接之前会分配，在查询完成后释放
      如何判断SQL使用了BNLJ？
	    explain select * from users a left join orders b on a.id = b.user_id;
		extra中出现了表示使用了BNLJ：Using join buffer (Block Nested Loop)
  3、批量键值访问算法，Batched Key Access Join(BKA)
	  MRR：将随机IO转换成顺序IO，从而提升性能，默认开启
	    背景：在非主键索引的范围查询条件下，可能会导致随机IO（数据实际存储是按照主键ID排列的，非主键索引过滤出来的数据主键ID顺序可能乱序，导致随机IO）
        optimizer_switch的子参数
		  mrr：是否开启mrr，on开启，off关闭
          mrr_cost_based：表示是否要开启基于成本计算的MRR
		read_rnd_buffer_size：指定mrr缓存大小，存放索引内存的大小
	  如何判断SQL使用了MRR？
	    # 基于成本的MRR默认很保守，关闭后MRR更容易被使用
        set optimizer_switch = 'mrr_cost_based=off;
		elplain中的extra包含Using MRR表示使用了MRR
	  BKA在MySQL5.6引入，BKA基石：Multi Range Read(MRR)
        BKA参数，optimizer_switch的子参数
	      batched_key_access：on开启，off关闭，默认关闭
	4、HASH JOIN，MySQL 8.0.18引入,用来替代BNLJ
	    https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html
        join buffer缓存外部循环的hash表，内层循环遍历时到hash表匹配
		MySQL8.0.18才引入，且有很多限制，比如不能作用于外连接，比如left join/right join等等
		从8.0.20开始限制少了很多，且废弃了BNLJ，建议用8.0.20或更高版本
		从MySQL 8.0.18开始，hash join的join buffer是递增分配的,这意味着，你可以为将join_buffer_size设置得比较大
		而在MySQL 8.0.18中如果你使用了外连接，外连接没法用hash join，此时join_buffer_size会按照你设置的值直接分配内存。因此join_buffer_size还是得谨慎设置
  总结：各种join的区别；熟练掌握NLJ、BNLJ的原理；了解BKA、HASH JOIN的原理
JOIN调优原则
  1、用小表驱动大表
      一般无需人工考虑，关联查询优化器会自动选择最优的执行顺序
	  但是也存在优化器判断不准确的情况，可以使用STRAIGHT_JOIN来强制指定左边的表驱动右边的表
  2、where条件要使用索引，尽可能减少外层循环数据量
  3、join的字段应该尽量创建索引，并且类型需要一致，explain 后跟 show warning;可查看
  4、尽可能减少扫描的行数，explain rows
  5、参与join的表不要太多，阿里规约建议不超过3张，可以拆分为多条查询若全部命中主键反而比一条SQL更快
  6、如果被驱动表的join字段用不了索引，且内存较为充足，可以考虑把join buffer设置的大一点
LIMIT语句调优
  explain select * from employees limit 300000,10; 
  1、使用覆盖索引，只查询索引字段
      explain select emp_no from employees limit 300000,10; 
  2、覆盖索引+join（先查询索引字段有哪些取值，然后再查询所有字段扫描这些索引）
      explain select * from employees e innor join
	    (select emp_no from employees limit 300000,10) t on e.emp_no = t.emp_no;
    join字段一样时可简写为
	  explain select * from employees e innor join
	    (select emp_no from employees limit 300000,10) t using(emp_no);
  3、覆盖索引+子查询（先查询到这一页的最先索引字段值，然后在在这个索引上取10条）
    select * from employees where emp_no >= (select emp_no from employees limit 300000,1) limit 10;
  4、范围查询+limit语句（拿到上一页的最大值）
    select * from employees where emp_no >= 10010 limit 10;
  5、拿到起始主键值和结束主键值
    select * from employees where emp_no between 20000 and 20010;
  6、需求上禁止传入过大的页码
COUNT语句的特性
  1.当没有非主键索引时，会使用主键索引
  2.如果存在非主键索引的话，会使用非主键索引
  3.如果存在多个非主键索引，会使用一个最小的非主键索引
      为什么?
      innodb非主键索引，叶子节点存储的是：索引+主键
      主键索引叶子节点：主键+表数据
      在1个page里面，非主键索引可以存储更多的条目，对于一张表，1000000数据，使用非主键索引扫描page 100，主键索引500
      所以使用最小的非主键索引扫描的页更少
  4、count(字段)会排除掉该字段值为null的行，没有特殊需求用count(*)
  5、count(*)和count(1)没有区别 https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_count
  6、对于MyISAM引擎，没有where条件的count(*)会非常快，InnoDB在8.0.13以上版本也对没有where条件的count(*)做了优化
COUNT语句的优化
  1、创建一个更小的非主键索引
  2、把数据库引擎换成MyISAM，实际项目用的很少，般不会修改数据库引擎
  3、汇总表table[table_name, count] = employees, 2000000
      好处：结果比较准确
      缺点：增加了维护的成本
  4、sql_calc_found_rows，在做完查询后自动的执行COUNT
      select sql_calc_found_rows * from salaries limit 10;
  	select found_rows() as salary_count;
    缺点：8.0.17已经废弃，后续会删除
  5、将count(*)结果缓存
    优点:性能比较高，结果比较准确
    缺点:引入了额外的组件，增加了架构的复杂度，需要维护
  6、information_schema.tables
    select * from information_schema.tables where table_schema = 'employees' and table_name = 'salaries';
    优点：不操作salaries表，不论salaries有 多少数据，都可以迅速地返回结果
    缺点：估算值，并不是准确值
  7、show table status where Name = 'salaries';
  8、explain select * from salaries;
  若计算某个范围的数量
    select count(*) from salaries where emp_no > 10010;
  最小emp_no与10010很接近，可采用总数 - <=10010的数反向计算来进行优化，也可使用汇总表和缓存来计算结果，减少扫描行数
    select count(*) - (select count(*) from salaries where emp_no <= 10010) from salaries;
ORDER BY优化
  最好的做法是：利用索引避免排序，利用索引本身的有序性让MySQL跳过排序的过程
  rowid排序
    1、从表中获取满足WHERE条件的记录
    2、对于每条记录,将记录的主键及排序键(id,order_column)取出放入sort buffer(由sort_buffer_size控制)，IO操作
    3、如果sort buffer能存放所有满足条件的(id,order_column)，则进行排序。否则sort buffer满后，排序并写到临时文件，排序算法：快速排序
    4、若排序中产生了临时文件，需要利用归并排序算法保证结果有序
    5、循环执行上述过程,直到所有满足条件的记录全部参与排序
    6、扫描排好序的(id,order_column)对，并利用id去取SELECT需要返回的其他字段，IO操作，取数据前会对ID放到read_rnd_buffer_size排序
    7、返回结果集
    特点：
      1、看sort buffer是否能存放结果集里面的所有(id,order_column)，如果不满足，就会产生临时文件
      2、一次排序需要两次IO
  全字段排序(优化排序)
    直接取出SQL中需要的所有字段,放到sort buffer，由于sort buffer已经包含了查询需要的所有字段
    因此在sort buffer中排序完成后可直接返回
    max_length_for_sort_data：当ORDER BY中出现字段的总长度小于该值，使用全字段排序，否则使用rowid排序
  打包字段排序：将字段紧密的排列在一起而不是使用固定长度空间
  优化：
    1、利用索引，防止filesort的发生
    2、如果发生了filesort，并且没办法避免，想办法优化filesort
    3、调大sort_buffer_size，减少/避免临时文件、归并操作
        optimizer trace中num_initial_chunks_spilled_to_disk的值
        sort_merge_passes变量的值
    4、调大read_rnd_buffer_size，让一次顺序IO返回的结果更多
    5、设置合理的max_length_for_sort_data的值，一般不建议随意调整
    6、调小max_sort_length(排序时最多取多少字节)
  OPTIMIZER_TRACE使用
  1、开启OPTIMIZER_TRACE功能，并设置要展示的数据条目数:
  SET OPTIMIZER_TRACE=”enabled=on", END_MARKERS_IN_JSON=on;
  SET optimizer_trace_offset=-30, optimizer_trace_limit=30;
  2、执行需要分析的SQL
  3、trace filesort_summary，select * from information_schema.optimizer_trace where query like '%xxx%';
  小结：
    什么场景下能用索引避免排序,什么场景下不能
    MySQL排序的三种模式，特点必须掌握，了解大概的步骤
    会用optimizer trace去分析filesort的结果

GROUP BY语句调优，1、2、3方式性能依次递减
  1、松散索引扫描(Loose Index Scan)：无需扫描满足条件的所有索引键即可返回结果
    分析这条SQL如何执行：explain select emp_no, min(salary) from salaries group by emp_no;
    表有[emp_no, salary]的组合索引
      [10001 , 50000]
      [10001 , 51000]
      ...
      [10002 , 30000]
      [10002 , 32000]
      ...
    普通扫描：
      1.先扫描emp_no = 10001的数据，并计算出最小的salary是多少，[10001, 50000]
      2.扫描emp_no = 10002，并计算出最小的salary是多少，[10002, 30000]
      3.遍历出每个员工的最小薪资，并返回
    改进: (松散索引扫描)
      1.先扫描emp_no = 10001的数据，取出第一条就是这个员工工资最小的数据
      2.直接跳过所有的emp_no = 10001的数据，继续扫描emp_no = 10002的数据，取第一条
      3.以此类推
    explain的extra展示Using index for group-by, 说明使用了松散索引扫描
    使用松散索引的条件：
      1、查询作用在单张表上
      2、GROUP指定的所有字段要符合最左前缀原则,且没有其他字段
          比如有索引index(c1, c2, c3), 如果GROUP BY c1, c2则可以使用松散引扫描; 但GROUP BY c2, c3和GROUP BY c1, c2, c4则不能
      3、如果存在聚合函数,只支持MIN()/MAX(),并且如果同时使用了MIN()和MAX(),则必须作用在同一个字段，
          聚合函数作用的字段必须在索引中,并且要紧跟GROUP BY所指定的字段。
          比如有索引index(c1, c2, c3), select c1, c2, min(c3), max(c3) from t1 group by c1, c2;可以使用松散索引扫描
      4、如果查询中存在除GROUP BY指定的列以外的其他部分,则必须以常量的形式出现
          比如select c1,c3 from t1 group by c1,c2;不能使用
          比如select c1,c3 from t1 where c3 = 3 group by c1,c2;可以
      5、索引必须索引整个字段的值, 不能是前缀索引
          比如有字段c1 VARCHAR(20), 但如果该字段使用的是前缀索引index(c1(10))而不是index(c1), 无法使用松散索引扫描
      6、其他特定聚合函数用法能用.上松散索引扫描的条件：
          AVG(DISTINCT)、SUM(DISTINCT)、 COUNT(DISTINCT) ,其中AVG(DISTINCT)、SUM(DISTINCT)可接受单个参数;
          而COUNT(DISTINCT)可接受多个参数。并且查询中必须不存在GROUP BY或DISTINCT语句，并且满足前面的5个条件。
  2、紧凑索引扫描(Tight Index Scan)：需要扫描满足条件的所有索引键才能返回结果
      性能一般比松散索引|扫描差,但一般都可接受。
      如下查询聚合函数字段为sum，使用了经凑索引，extra没有明显标识，type=index extra=Using index
      explain select emp_no, sum(salary) from salaries group by emp_no;
  3、临时表(Temporary table)
      紧凑索引扫描也没有办法使用的话, MySQL将会读取需要的数据, 并创建一个临时表, 用临时表实现GROUP BY操作
      如下字段查询字段无索引，将使用临时表, type=all extra=Using temporary
      explain select max(hire_date) from employees group by hire_date;
  优化：如果GROUP BY使用了临时表,想办法用上松散索引扫描或紧凑索引扫描
DISTINCT语句调优
  DISTINCT是在GROUP BY操作之后, 每组只取1条, 和GROUP BY优化思路-样
总结：
松散索引扫描, 性能最好, explain中会有Using index for group-by
紧凑索引扫描, 性能第二, explain中无明显标识
临时表, 性能最差, explain中会有Using temporary
避免临时表,使用松散/紧凑索引扫描

表设计
  第一范式(1NF)
    字段具有原子性,即数据库表的每一个字段都是不可分割的原子数据项,不能是集合、数组、记录等非原子数据项
    当实体中的某个属性有多个值时,必须拆分为不同的属性
  第二范式(2NF)
    满足1NF的基础上, 要求每一行数据具有唯一性, 并且非主键字段完全依赖主键字段
    两个字段为表的联合主键，某字段只与主键其中一个字段有关而与另外一个无关，需要拆成两个表
  第三范式(3NF)
    满足2NF的基础上, 不能存在传递依赖
    表中字段需要直接依赖与主键，而不能依赖与其中一个字段，该字段依赖主键来使得产生传递依赖
    需要新增表，使字段直接依赖于主键
  三范式的好处一般是用于防止数据冗余, 但在实际项目中存在反模式设计, 适当增加冗余, 从而提升查询效率
表设计原则
  1、字段少而精, 建议20个以内(经验之谈), 超过可以拆分
      把常用的字段放到一起
      把不常用的字段独立出去
      大字段(TEXT/BLOB/CLOB等等)独立出去
  2、尽量用小型字段
      用数字替代字符串
  3、避免使用允许为NULL的字段
      允许NULL字段很难查询优化
      允许为NULL字段的索引需要额外空间
  4、合理平衡范式与冗余
  5、如果数据量非常大,考虑分库分表
MySQL大表优化方案（精华文章）
https://segmentfault.com/a/1190000006158186

Percona Toolkit
  官网：https://www.percona.com/doc/percona-toolkit/3.0/index.html
  分析慢查询日志：pt-query-digest mysql-slow-2022-01-07.log > 0107.report


































































