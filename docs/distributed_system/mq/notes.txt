分布式消息队列(MQ)应用场景：服务解耦、削峰填谷、异步化缓冲（最终一致性，柔性失误）
分布式消息队列应用思考：
生产端可靠性投递(不可丢失，原子性)、消费端幂等(一条消息只能消费一次)
高可用、低延迟、可靠性、消息堆积能力、可扩展性
技术选型注意点：根据业务场景考虑各个MQ的优缺点和性能、集群架构模式(分布式、可扩展、高可用、可维护性)、综合成本问题(集群规模、人员成本)、未来的方向线规划与思考
ActiveMQ：适合传统型公司业务以及互联网边缘行业，消息并发与沉载能力较弱，不适用于较大并发的场景，只用zookeeper做主备切换
RabbitMQ：横向扩展能力不是很好需要添加路由组件，可用性可维护性较好
kafka：消息可靠性依赖不高首选，可在很廉价的机器上有非常高的性能与吞吐量的表现

RabbitMQ集群架构模型：
主备模式：热备份，master对外提供读写，slave仅进行备份。master挂掉之后slave成为master。
远程模式：早提提供的多活存储，主要做数据异地容灾，也可提升性能(当前集群处理不过来时会将请求会发到下游集群)，架构简单配置复杂(一般用多活模式替代该模式)
镜像模式：业界使用最为广泛的模式，保证消息非常可靠
多活模式：做一个异地存容灾，数据转储

主备模式(warren 兔子窝)
使用HaProxy路由到master，master挂掉之后路由到slave
远程模式使用shovel插件将两个集群互联
镜像模式(Mirror)：一般互联网大厂都使用该模式，也使用HaProxy搭建
多活模式：Federation插件

kafka：分布式、跨平台(支持不同语言)、实时性、伸缩性
高性能的原因：
顺序写、Page Cache(OS级别，顺序读文件，不显示的用内存)、空中接力
高效读写、高性能高吞吐
后台异步、主动flush
预读策略、IO调度
Page Cache(页面缓存)：操作系统实现的主要的磁盘缓存，减少对磁盘的IO操作，将磁盘中的数据缓存到内存中，将对磁盘的访问变成对内存的访问
zero拷贝：原始程序从读取文件内容发送到其他进程需要四次拷贝，zero拷贝只进行一次拷贝
将磁盘文件复制到页面缓存(内核读取缓冲区)一次，然后直接发送到网卡接口


