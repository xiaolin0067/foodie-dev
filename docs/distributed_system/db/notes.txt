# 数据切分
数据切分，简单的说，就是通过某种条件，将我们之前存储在一台数据库上的数据，分散到多台数据库中，从而达到降低单台数据库负载的效果。
数据切分，根据其切分的规则，大致分为两种类型，垂直切分和水平切分。

## 垂直切分：就是按照不同的表切分到不同的数据库中，比如使得订单表（order）和商品表（product）分别落到不同的物理机中的不同的数据库中。
优点：
1、拆分后业务清晰，拆分规则明确；
2、系统之间容易扩展和整合；
3、数据维护简单
缺点：
1、部分业务表无法join，只能通过接口调用，提升了系统的复杂度；
2、跨库事务难以处理；
3、垂直切分后，某些业务数据过于庞大，仍然存在单体性能瓶颈；

## 水平切分：水平切分相比垂直切分，更为复杂。它需要将一个表中的数据，根据某种规则拆分到不同的数据库中。
例如：订单尾号为奇数的订单放在了订单数据库1中，而订单尾号为偶数的订单放在了订单数据库2中。
我们看看几种水平拆分的典型的分片规则：
1、用户id求模，我们前面已经提到过；
2、按照日期去拆分数据；
3、按照其他字段求模，去拆分数据；
优点：
1、解决了单库大数据、高并发的性能瓶颈；
2、拆分规则封装好，对应用端几乎透明，开发人员无需关心拆分细节；
3、提高了系统的稳定性和负载能力；
缺点：
1、拆分规则很难抽象；
2、分片事务一致性难以解决；
3、二次扩展时，数据迁移、维护难度大（刚开始将业务数据拆分到两个数据库，后面要增加拆分到三台数据库）。

## 垂直切分与水平切分的共同缺点有：
1、分布式的事务问题；
2、跨库join问题；
3、多数据源的管理问题
针对多数据源的管理问题，主要有两种思路：
客户端模式，在每个应用模块内，配置自己需要的数据源，直接访问数据库，在各模块内完成数据的整合；
中间代理模式，中间代理统一管理所有的数据源，数据库层对开发人员完全透明，开发人员无需关注拆分的细节。
基于这两种模式，目前都有成熟的第三方软件，接下来在我们的视频中，会分别给大家介绍这两种模式的代表作：
中间代理模式：MyCat
客户端模式：sharding-jdbc

# 数据库读写分离
让所有读的请求落到专门负责读的数据库上，所有写的操作落到专门负责写的数据库上，写库的数据同步到读库上。
读写分离的弊端：当同步挂掉，或者同步延迟比较大时，写库和读库的数据不一致。
如何正确的使用读写分离：一些对数据实时性要求不高的业务场景，可以考虑使用读写分离。


# Sharding-Jdbc
https://shardingsphere.apache.org/
是一个开源的分布式关系型数据库中间件，客户端代理模式，轻量级Java框架以jar提供服务。
Mycat不支持同一库内的水平切分，Sharding-Jdbc支持


# 全局唯一ID
UUID、统一ID序列表、推特雪花算法
UUID：sharding-jdbc支持自动插入UUID并进行分片，可自定义分片规则

mycat可使用数据库的自增ID来创建统一ID序列表
1、编辑server.xml，配置序列自增类型为1
2、在一个数据节点上初始化mycat提供的SQL脚本，并添加一个需要设置全局自增ID的记录
3、编辑sequence_db_conf.properties配置表节点

雪花算法：64bit的long数字，引入时间戳，保持自增。
结构：
0 41位时间戳 5位机房 5位机器 12位序列号
2、基本保持全局唯一，毫秒并发4096个ID
1、事件回调可能引起ID重复


# 分布式事务解决方案
XA协议的两阶段提交，XA是由X/Open组织提出的分布式事务规范
由一个事务管理器(TM)和多个资源管理器组成(RM)，提交分为两个阶段：prepare和commit
mysql5.7+，mysql connect 5.0+支持xa协议，在Java中数据源使用Atomikos
springboot使用Atomikos：
1、引入spring-boot-starter-jta-atomikos依赖
2、配置两个数据源(RM)（须使用MysqlXADataSource并放入AtomikosDataSourceBean中进行管理），配置SqlSessionFactoryBean
3、配置JtaTransactionManager事务管理器(TM) xaTransaction
4、使用@Transactional(transactionManager="xaTransaction")

## mycat默认支持分布式事务，可直接使用，sharding-jdbc也默认支持
server.xml中配置项handleDistributedTransactions默认配置为0支持分布式事务
程序中方法上加上@Transactional(rollbackFor = Exception.class)即可
命令行中测试：
set autocommit = 0;
set xa = on;
insert ......
commit;

## 事务补偿机制：针对每个操作都要注册一个与之对应的补偿(撤销)操作，在执行失败时进行撤销
优点：逻辑清晰、流程简单
缺点：数据一致性比XA还要差，可能出错的点很多
TCC属于应用层的一种补偿机制，程序员需要编写大量代码

## 本地消息表的最终一致方案
将支付成功的消息存入本地消息表中，使用定时任务去处理消息以达到最终一致性
优点：避免了分布式事务，实现了最终一致性
缺点：要注意重试时的幂等性

## 基于MQ的最终一致方案
原理流程与本地消息表类似，不同点：
1、本地消息表改为MQ
2、定时任务改为MQ的消费者
优点：不依赖定时任务，基于MQ更加高效可靠








