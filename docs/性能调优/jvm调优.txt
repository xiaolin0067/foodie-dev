JVM内存结构：
一、堆：线程共享，JVM中最大的一块内存，绝大多数对象在此创建
Eden, From survivor, To survivor | Tenured | Metaspace
伊甸园             存活区
         新生代                       老年代    元空间(本地内存大小取决于机器内存，不属于JVM虚拟机)
二、方法区：线程共享
存于堆中
  1、静态变量
  2、字符串常量池
    字符串常量池，也可以理解成运行时常量池分出来的一部分，类加载到内存的时候，字符串，会存到字符串常量池里面
存于元空间中(本地内存)
  3、运行时常量池
    当类加载到内存中后，JVM就会将静态常量池中的内容存放到运行时的常量池中﹔运行时常量池里面存储的主要是编译期间生成的字面量、符号引用等等
  4、类信息：类的版本、字段描述信息、方法描述信息、接口和父类等描述信息、class文件常量池(静态常量池)
    class文件常量池(静态常量池)包含：
      字面量:例如文本字符串、final修饰的常量
      符号引用:例如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
三、虚拟机栈：线程隔离，管理的是Java方法
创建线程时就会创建一个虚拟机栈，由栈帧组成，每一次的方法调用都会创建一个栈帧，然后再虚拟机栈上进行压栈，当方法返回进行出栈
栈帧包含内容：
  1、局部变量表：方法执行时从局部变量表或实例的字段中获取数据复制变量或常量放入操作数栈中
  2、操作数栈：计算时，往操作数栈中放入数据或取出数据进行计算，用来存放临时数据的地方
  3、指向运行时常量池的引用
  4、方法返回地址
  5、动态链接
四、本地方法栈：线程隔离，作用同虚拟机栈，管理的对象不同，本地方法栈管理的native方法
五、程序计数器：线程隔离，记录各个线程执行字节码的地址，如分支、跳转、循环、异常等等操作都需要依赖程序计数器。
  为何需要程序计数器：Java是多线程语言，当线程发生切换在次获得CPU时间片时需要知道线程执行到了哪一行，从何处继续执行。

方法内联
  即时编译器在编译期间把方法调用连接起来（把两个方法合并到一起），来减少方法调用压栈和出栈操作的开销。
  方法调用存在压栈和出栈的操作，若方法为热点方法调用方法压栈和出栈开销也不低。
方法内联的条件：
1、方法体足够小
  热点方法︰如果方法体小于325字节会尝试内联，可用-XX:FreqInlineSize修改大小
  非热点方法∶如果方法体小于35字节，会尝试内联，可用-Xx:MaxInlinesize修改大小
2、被调用方法运行时的实现被可以唯一确定
  static方法、private方法及final方法，JIT可以唯一确定具体的实现代码
  public的实例方法，指向的实现可能是自身、父类、子类的代码，当且仅当IT能够唯一确定方法的真体实现时，才有可能完成内联
方法内联注意点：
  1、尽量让方法体小一些
  2、尽量使用final、private、static关键字修饰方法，避免因为多态，需要对方法做额外的检查
  3、一些场景下，可通过JVM参数修改阈值，从而让更多方法内联
内联可能带来的问题：CodeCache的溢出，导致JVM退化成解释执行模式
  参数名 默认 说明
  -XX:+UnlockDiagnosticVMOptions - 打印JVM诊断相关的信息
  -XX:+PrintInlining - 打印内联详情，该参数需和-XX:+UnlockDiagnosticVMOptions配合使用
  -XX:MaxInlineSize=n 35 如果非热点方法的字节码超过该值，则无法内联，单位字节
  -XX:FreglnlineSize=n 325 如果热点方法的字节码超过该值，则无法内联，单位字节
  -XX:InlineSmallCode=n 1000 目标编译后生成的机器码代销大于该值则无法内联，单位字节
  -XX:MaxInlineLevel=n 9 内联方法的最大调用帧数（嵌套调用的最大内联深度)
  -XX:MaxTrivialSize=n 6 如果方法的字节码少于该值，则直接内联，单位字节
  -XX:MinInliningThreshold=n 250 如果目标方法的调用次数低于该值，则不去内联
  -XX:LiveNodeCountlnliningCutoff=n 40000 编译过程中最大活动节点数(IR节点)的上限，仅对C2编译器有效
  -XX:InlineFrequencyCount=n 100 如果方法的调用点(call site)的执行次数超过该值，则触发内联
  -XX:MaxRecursivelnlineLevel=n 1 递归调用大于这么多次就不内联
  -XX:InlineSynchronizedMethods 开启 是否允许内联同步方法
一般来说不要设置此类参数，出现问题可参考相关参数调优

逃逸分析：分析变量能否逃出它的作用域
  全局变量赋值逃逸
  方法返回值逃逸
  实例引用逃逸
  线程逃逸：赋值给类变量或可以在其他线程中访问的实例变量
全局级别逃逸：
  一个对象可能从方法或者当前线程中逃逸
  对象被作为方法的返回值
  对象作为静态字段(static field)或者成员变量(field)
  如果重写了某个类的finalize()方法，那么这个类的对象都会被标为全局洮逸状态并自一定会放在堆内存中
参数级别逃逸：
  对象被作为参数传递给一个方法，但是在这个方法之外无法访问/对其他线程不可见

标量替换
通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是创建它的成员变量来代替
-XX:+EliminateAllocations开启标量替换(JDK 8默认开启)
标量:不能被进一步分解的量
  基础数据类型
  对象引用
聚合量:可以进—步分解的量，如String

栈上分配
通过逃逸分析，能够确认对象不会被外部访问，就在栈上分配对象，减少垃圾回收压力。

参数 默认值(JDK 8) 作用
-XX:+DoEscapeAnalysis 开启 是否开启逃逸分析
-XX:+EliminateAllocations 开启 是否开启标量替换
-XX:+EliminateLocks 开启 是否开启锁消除





