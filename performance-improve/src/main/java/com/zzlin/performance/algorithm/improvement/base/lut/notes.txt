P18 17.基础提升 暴力递归（下）等

有序表(LUT-lookup table)，其所有操作的时间复杂的都是log(n)级别

实现方式数据结构：红黑树、AVL、SB(size balance tree)、跳表(skip list)
四种数据结构的时间复杂度是一样的，没有谁明显更好，只是原理不一样。BS结构常用于比赛，因其结构便于修改于扩展
大致分为两个系列
一、平衡搜索二叉树：红黑树、AVL、BS。
二、单链表的改写：跳表

搜索二叉树
添加：
从头节点开始，大于该节点往左滑，小于该节点往右滑
若找到了该节点：压缩(计数+1)、替换
若没有找到该节点：添加
搜索：
从头节点开始，大于左子树大于他，右子树小于他
删除：
先确定节点是否在这棵树上，记录节点的夫节点
1、节点无孩子：直接删除，把夫节点的指针改为null
2、节点只有一个孩子：抹掉节点，让其夫节点和子节点直接相连，子节点替换自己
3、节点有两个孩子：让左子树的最右节点来替，或者让右子树的最左节点来替。若最右/左节点存在左/右子树的话，直接与移除用于代替节点的父节点相连。

搜索二叉树的问题：树形结构依赖于用户给出的数据，其时间复杂度不能保证为log(n)

AVL树
红黑树、AVL、BS，三种树本质都是二叉搜索树、增加了左旋与右旋的操作。不同点是各自对平衡性的定义不同。
平衡性：
广义：任何一个节点的左树与右树的节点数不至于相差的太过悬殊
狭义：如平衡搜索二叉树(AVL)的条件：任何一个节点的左树与右树的高度差不超过1

平衡搜索二叉树的条件：任何一个节点的左树与右树的高度差不超过1，节点记录的是height

树形旋转：头节点往哪边(左/右)倒，头节点倒向哪边就是哪旋。其主要意义为可以让树变更平衡一些。
左旋：头节点倒向左边，右孩子成为新的头。新头节点右树不变，左孩子为原头节点，新头节点原左树成为原头节点的右树。原头节点左树不变。
右旋：头节点倒向右边，左孩子成为新的头。新头节点左树不变，右孩子为原头节点，新头节点原右树成为原头节点的左树。原头节点右树不变。

严格平衡性(AVL)检查平衡性的时机：
1、添加节点：同搜索二叉树的添加，添加完成后回到头节点路径并对每个节点的平衡性进行检查，若不平衡选择左右旋。
2、删除节点：同搜索二叉树的删除，删除完成后，从替代节点的夫节点开始往删除节点位置的路径进行平衡性检查，若不平衡选择左右旋。

平衡性被破坏的四种情况情况
LL型：左孩子的左边界过长，做一次右旋
RR型：右孩子的右边界过长，做一次左旋
LR型：左树的右边过长，让左树的右孩子成为头节点，涉及左旋与右旋
RL型：右树的左边过长，让右树的左孩子成为头节点，
这四种调整的代价都是常数级别的

SB树
平衡性：每棵子树的大小不小于其兄弟的子树的大小，既每棵叔叔的树的大小，不小于其任何侄子树的大小，节点记录大小size值
LL型：左孩子的左孩子大小大于了右孩子的大小；头节点右旋，检查子树变化了的节点的平衡性
RR型：类似LL型
LR型：左孩子的右孩子大小大于了右孩子的大小；类似AVL的LR型，先左旋后右旋，让左孩子的右孩子成为头节点，检查子树变化了的节点的平衡性
RL型：类似LR型

红黑树
红黑树现在没有人用了，只是一场智力盛宴而已，没有必要学习，一定会被遗弃，SB树与AVL树都比他强
节点记录：红/黑
1、每个节点不是红就是黑
2、整棵树的头节点和叶节点(最下面的为null的节点)为黑
3、任何两个红节点不能相邻(既黑节点可以相邻)
4、对于任何一颗子树来说，从某一个头部cur出发，到他叶节点的每一条路径要求黑节点数量一样
基于以上规则有
最长的路：红黑交替的路
最短的路：全是黑节点
核心：保证路径长度的倍数，最长的路不会大于最短的路的两倍

跳表
初始化有一个默认节点，该节点有一条路径
新增节点时默认一条路径，然后在0-1之间生成随机数，若为0则不添加路径，为1则添加一条路径并且再次生成随机数
默认节点中的路径为所有节点的最大路径数
从默认节点的最大路径开始找新增节点的值，往右找，并在对应位置添加节点（具体看视频的图，流程有点点多）

三个月如果包装成三年
简历
一、个人信息，联系方式
二、教育经历
三、技能清单：数据库（DB2，mysql，mongodb，hdfs）、框架、消息队列
四、项目经历：不要写太多业务，突出用了什么技术及其特性，调研，简单说下解决了什么问题
    1、调研aws，aliyun云平台的最热的好用的工具（消息队列，对象存储），学习其文档（很详细），技术概念，选择五到六个
    2、这些技术概念对应的开源产品的使用进行学习和使用
    3、根据这些工具或概念植入业务，着重说明技术而非业务
五、个人评价：突出对于技术的看法








