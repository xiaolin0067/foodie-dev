贪心算法
在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫作贪心算法。
也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。
局部最优 —?-> 整体最优

贪心算法的在笔试时的解题套路
1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2，脑补出贪心策略A、贪心策略B、贪心策略C...
3，用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
4，不要去纠结贪心策略的证明
根据心理的一个标准依次考虑每一个样本

题目一：
一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。
给你每一个项目开始的时间和结束的时间(给你一个数组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。
返回这个最多的宣讲场次。

策略：
1、最先开始的会议
2、会议时间最短的会议
3、结束时间最早的会议（局部最优）

题目二（哈夫曼编码问题）：
一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。
一群人想整分整块金条，怎么分最省铜板?
例如,给定数组{10,20,30]，代表一共三个人，整块金条长度为10+20+30=60。金条要分成10,20,30三个部分。
如果先把长度60的金条分成10和50，花费60;再把长度50的金条分成20和30，花费50;一共花费110铜板。
但是如果先把长度60的金条分成30和30，花费60:再把长度30金条分成10和20花费30;一共花费90铜板。



题目三：
输入
正数数组costs
正数数组profits
正数k
正m
含义:
costs[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)
k表示你只能串行的最多做k个项目，m表示你初始的资金
说明:
你每做完一个项目，马上获得的收益，可以支持你去做下一个项目，项目不可重复做
输出:你最后获得的最大钱数


暴力递归就是尝试
1、把问题转化为规模缩小了的同类问题的子问题
2,有明确的不需要继续进行递归的条件(base case)
3、有当得到了子问题的结果之后的决策过程
4、不记录每一个子问题的解
一定要学会怎么去尝试，因为这是动态规划的基础，这一内容我们将在提升班讲述。

题目
汉诺塔问题：将一根杆上的不同大小圆盘移动到另外一个圆盘，一次只能移动一个圆盘，小的圆盘上不可以放更大的圆盘。
打印n层汉诺塔从最左边移动到最右边的全部过程

题目
打印一个字符串的全部子序列，包括空字符串

题目
打印一个字符串的全部排列
打印一个字符串的全部排列，要求不要出现重复的排列

题目
给定一个整型数组arr，代表数值不同的纸牌排成一条线。
玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。
请返回最后获胜者的分数。
[举例]
arr=[1,2,100,4]。
开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2,100,4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A...
如果开始时玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A...
玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。
所以玩家A会先拿1让排列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家 A拿走。玩家A会获胜分数为101。所以返回101。
arr=[1,100,2]。
开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜分数为100。所以返回100。

题目
给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数如何实现?

题目
规定1和A对应、2和B对应、3和C对应...
0无法和任何字母对应，只能为10/20
那么一个数字字符串比如”111”，就可以转化为"AAA”、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果

题目
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表i号物品的重量和价值。
给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少?


尝试原则：可变参数形式最简单（值就可以表达而不是链表或其他数据结构），可变参数数量最少
























