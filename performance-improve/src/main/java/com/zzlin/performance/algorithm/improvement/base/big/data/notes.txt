大数据(资源限制类)题目的解题技巧

1)哈希函数可以把数据按照种类均匀分流
2)布隆过滤器用于集合的建立与查询，并可以节省大量空间
3)一致性哈希解决数据服务器的负载管理问题
4)利用并查集结构做岛问题的并行计算
5)位图解决某一范围上数字的出现情况，并可以节省大量空间
6)利用分段统计思想、并进一步节省大量空间
7)利用堆、外排序来做多个处理单元的结果合并

hash分流（万能的方法）

mapper-reduce 大问题拆分成小问题求解，在合并答案

之前的课已经介绍过前4个内容，本节内容为介绍解决大数据题目的后3个技巧

题目一
32位无符号整数的范围是[0, 4294967295], 现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。
可以使用最多1GB的内存，怎么找到所有未出现过的数?

直接申请(2^32) / 8个字节数组，用每一位表示文件中的数字是否出现
byte[] byteArr = new byte[(2^32) / 8]; // 内存占用512MB
遍历大文件数字，找到对应下标，若出现过则改为1
最后遍历结果数组，为0的即未出现的数

[进阶]
内存限制为10MB，但是只用找到一个没出现过的数即可

内存限制为3KB?
1、3000 / 4 向下取2的幂为 512
2、申请一个整形数组
int[] intArr = new int[512];
  其中每一个下标的值代表该区间数字出现了多少次
  4294967296 / 512 = 8388608
  intArr[0]代表0~8388607范围的数子一共出现了多少次
  intArr[1]代表8388608~16777215范围的数子一共出现了多少次
  ...
3、读取文件数字X，intArr[X / 8388608]++
  统计范围的词频，因为40亿少于4294967295个数，遍历文件结束后必定存在有一个下标的词频是少于8388608的(只找小于8388608的，超过的不管)
3、遍历intArr，找到值小于8388608的，然后再次把这个范围划分进行词频统计，周而复始总能得到没出现过的数字

只能定义有限的几个变量?
0 ~ (2^32)-1进行二分，左右侧必定有一侧是不满的，再次对不满的那一侧进行二分，最多遍历32次文件得到不存在的数字

题目二
有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL

1、hash分流：遍历大文件的URL计算hash值，取模分隔到多个小文件里，然后对每个小文件URL进行比较，最后汇总结果
2、布隆过滤器：遍历大文件URL计算hash，先从布隆过滤器中通过hash值判断若已经存在了，就将该URL加入到重复URL的文件中（有一定失误率）

可以问面试官：机器台数、硬盘大小、内存、是否允许失误率

[补充]
某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法

二维堆结构
1、使用hash分流的方式，将词汇拆分到多个小文件中，然后在对每个小文件的词频进行统计，生成一个前100名的大根堆
2、使用每个小文件生成的堆的堆顶再生成一个大顶堆
3、从这个大顶堆中取前100名，取堆顶后，在将这个值所在小文件的堆顶再次拿来重新生成第二步的大顶堆

题目三
32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。
解：
1、hash分流，小文件中找到出现2次的数，最后合并结果
2、用两个bit位来表示一个数出现的次数：
    00-0次
    01-1次
    10-2次
    11-2次以上
数字范围是[0, (2^32) - 1]，若使用两个bit内存的话需要：(2^32) * 2 / 8 / 1024 / 1024 = 512MB

[补充]
可以使用最多10MB的内存，怎么找到这40亿个整数的中位数?
解：
分段词频统计
例如：
[2028 * 499 ~ (2048 * 500) - 1]          [2028 * 500 ~ (2048 * 501) - 1]
arr[499]                                 arr[500]
arr[0] + arr[1] +...+arr[499] = 18亿
arr[500] = 5亿
那么：
将arr[500]的[2028 * 500 ~ (2048 * 501) - 1]范围再次划分，找第2亿个数

大文件中数字排序(腾讯原题)
1、定义一个大根堆，堆中存放结构{数字:出现次数}，根据可用内存限制堆的大小
2、定义一个变量等于大文件数字范围的最小值，如：Y = -2^32
3、遍历大文件中的数字，若数字不小于Y则进行处理：
    a)若数字已存在，则将其出现次数+1
    b)若数字不存在且堆还有空余空间，直接入堆，出现次数为1
    c)若数字不存在且堆没有空余空间，检查数字是否小于堆顶，是则移除堆顶自己入堆，否则不处理该数字


题目四
位运算的题目
给定两个有符号32位整数a和b，返回a和b中较大的
[要求]
不用做任何比较判断

题目五
判断一个32位正数是不是2的幂、4的幂
// 获得最右侧的为1的位置
int rightIndex = aor1 & (~aor1 + 1);

题目六
给定两个有符号32位整数a和b，不能使用算术运算符，分别实现a和b的加、减、乘、除运算
[要求]
如果给定a、b执行加减乘除的运算结果就会导致数据的溢出，那么你实现的函数不必对此负责，除此之外请保证计算过程不发生溢出










