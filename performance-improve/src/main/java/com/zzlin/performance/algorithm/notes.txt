时间复杂度：
  最坏情况下的复杂度表示：O(N)
  平均状况下的复杂度表示：θ(N)
  最好情况下的复杂度表示：Ω(N)

位运算比算数运算快得多
异或：相同为0不同为1
  其效果可以理解为：不进位的相加
  有以下性质：
    1、0^N = N, N^N = 0
    2、满足交换律结合律，a^b=b^a, (a^b)^c=a^(b^c)
    3、一堆数随便怎么两两异或最后的结果是一样的

二分查找法，时间复杂度为O(logN)
  常规来说，使用二分查找需要数组是有序的，在某些情况下对于无序数组也可使用二分：
  如：局部最小值问题，数组中相邻两个数一定不一样，求局部最小值

对数器：
  实现一个随机生成测试数据的方法，来对两个方法进行循环测试，比对测试结果是否一致
  1，有一个你想要测的方法a
  2，实现复杂度不好但是容易实现的方法b3，实现一个随机样本产生器
  4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
  5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
  6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

master公式：T(N) = a * T(N/b) + O(N^d)
  https://blog.gocalf.com/algorithm-complexity-and-master-theorem
  一个主任务可以分为几个相同的子任务，分析出a, b, d的值，则可以使用如下方式计算时间复杂度
  1) log(b,a) > d -> 复杂度为O(N ^ log(b,a))
  2) log(b,a) = d -> 复杂度为O(N ^ d * logN)
  3) log(b,a) < d -> 复杂度为O(N ^ d)

堆
1，堆结构就是用数组实现的完全二叉树结构
2，完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3，完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4，堆结构的heaplnsert与heapify操作
5，堆结构的增大和减少
6，优先级队列结构，就是堆结构

堆是一种特殊的二叉树，用数组实现的完全二叉树结构
  大顶(根)堆：每个节点的值都大于或者等于它的左右子节点的值。
  小顶(根)堆：每个节点的值都小于或者等于它的左右子节点的值。
对于index有：
  左子节点 = 2 * index + 1
  右子节点 = 2 * index + 2
  父节点 = (index - 1) / 2

比较器的使用
  1）比较器的实质就是重载比较运算符
    返回负数的时候,第一个参数排在前面
    返回正数的时候,第二个参数排在前面
    返回0的时候,谁在前面无所谓
  2）比较器可以很好的应用在特殊标准的排序上
  3）比较器可以很好的应用在根据特殊标准排序的结构上

不基于比较的排序，需要根据数据状况来进行定制，应用范围窄
  桶排序（桶是容器，具体可以是队列，数组，栈都可以成为桶）
    1、计数排序：对在一定范围的数进行计数，对计数结果取出来即有序
      对员工年龄排序，年龄范围一般在 0~200，创建一个arr[200]的数组，对于出现的每个数都在数组中对应位置上的数加一
      最后返回数组中的各项
    2、基数排序：
      将所有数的左侧按最高位补0，然后从低位开始将每种数字放到队列中，相同的则追加到队列，然后在将数字队列由小往大依次出队
      由低位到高位依次重复

















