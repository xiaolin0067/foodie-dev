时间复杂度：
  最坏情况下的复杂度表示：O(N)
  平均状况下的复杂度表示：θ(N)
  最好情况下的复杂度表示：Ω(N)

位运算比算数运算快得多
异或：相同为0不同为1
  其效果可以理解为：不进位的相加
  有以下性质：
    1、0^N = N, N^N = 0
    2、满足交换律结合律，a^b=b^a, (a^b)^c=a^(b^c)
    3、一堆数随便怎么两两异或最后的结果是一样的

二分查找法，时间复杂度为O(logN)
  常规来说，使用二分查找需要数组是有序的，在某些情况下对于无序数组也可使用二分：
  如：局部最小值问题，数组中相邻两个数一定不一样，求局部最小值

对数器：
  实现一个随机生成测试数据的方法，来对两个方法进行循环测试，比对测试结果是否一致
  1，有一个你想要测的方法a
  2，实现复杂度不好但是容易实现的方法b3，实现一个随机样本产生器
  4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
  5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
  6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

master公式：T(N) = a * T(N/b) + O(N^d)
  https://blog.gocalf.com/algorithm-complexity-and-master-theorem
  一个主任务可以分为几个相同的子任务，分析出a, b, d的值，则可以使用如下方式计算时间复杂度
  1) log(b,a) > d -> 复杂度为O(N ^ log(b,a))
  2) log(b,a) = d -> 复杂度为O(N ^ d * logN)
  3) log(b,a) < d -> 复杂度为O(N ^ d)

堆
1，堆结构就是用数组实现的完全二叉树结构
2，完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3，完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4，堆结构的heaplnsert与heapify操作
5，堆结构的增大和减少
6，优先级队列结构，就是堆结构

堆是一种特殊的二叉树，用数组实现的完全二叉树结构
  大顶(根)堆：每个节点的值都大于或者等于它的左右子节点的值。
  小顶(根)堆：每个节点的值都小于或者等于它的左右子节点的值。
对于index有：
  左子节点 = 2 * index + 1
  右子节点 = 2 * index + 2
  父节点 = (index - 1) / 2

比较器的使用
  1）比较器的实质就是重载比较运算符
    返回负数的时候,第一个参数排在前面
    返回正数的时候,第二个参数排在前面
    返回0的时候,谁在前面无所谓
  2）比较器可以很好的应用在特殊标准的排序上
  3）比较器可以很好的应用在根据特殊标准排序的结构上

不基于比较的排序，需要根据数据状况来进行定制，应用范围窄
  桶排序（桶是容器，具体可以是队列，数组，栈都可以成为桶）
    1、计数排序：对在一定范围的数进行计数，对计数结果取出来即有序
      对员工年龄排序，年龄范围一般在 0~200，创建一个arr[200]的数组，对于出现的每个数都在数组中对应位置上的数加一
      最后返回数组中的各项
    2、基数排序：
      将所有数的左侧按最高位补0，然后从低位开始将每种数字放到队列中，相同的则追加到队列，然后在将数字队列由小往大依次出队
      由低位到高位依次重复

排序算法的稳定性及其汇总
  稳定性：同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的，否则就没有。
    相同的值在原数组中的顺序在排序后还是相同的顺序，就是稳定性
  不具备稳定性的排序:
    选择排序、快速排序、堆排序
  具备稳定性的排序:
    冒泡排序、插入排序、归并排序、一切桶排序思想下的排序（计数排序、基数排序）
  目前没有找到时间复杂度O(N*logN)，额外空间复杂度0(1)，又稳定的排序。

排序总结
算法       时间复杂度    空间复杂度    能否做到稳定性
选择排序      O(N^2)      O(1)         否
冒泡排序      O(N^2)      O(1)         是
插入排序      O(N^2)      O(1)         是
归并排序     O(N*logN)    O(N)         是
快速排序     O(N*logN)    O(logN)      否
堆排序       O(N*logN)    O(1)         否
一般使用快速排序，若需节省内存使用堆排序，若需做到稳定性使用归并排序
1、基于比较的排序，能否做到时间复杂度低于O(N*logN)？目前来说没有，无法做到
2、基于比较的排序，做到时间复杂度为O(N*logN)并且空间复杂度在O(N)以下，还能做到稳定？目前来说没有，无法做到

常见的坑
1，归并排序的额外空间复杂度可以变成0(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序内部缓存法”
    代码复杂，修改后会丧失稳定性，何不用堆排序代替
2，“原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(1)
    但是会让时间复杂度编程O(N^2)，何不用插入
3，快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01 stable sort”
    会让空间复杂度变成O(N)，何不用归并
4，所有的改进都不重要，因为目前没有找到时间复杂度0(N*logN)，额外空间复杂度0(1)，又稳定的排序。
5，有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。
    要求时间复杂度O(N)，空间复杂度O(1)

工程上对排序的改进
1、充分利用时间复杂度为O(N*logN)和O(N^2)算法的各自的优势
  综合排序：
  大样本量采用快排来进行调度，小样本量使用插入排序，将两种排序方法拼在一起。
  为什么：插入排序时间复杂度虽然为O(N^2)，但小样本量时瓶颈不明显，反而常数时间众所周知是极低的
  利用了快速排序大样本量的调度优势，又利用了小样本量插入排序常数时间低的优势
2、稳定性考虑
  Arrays.sort()对于基础类型使用快速排序，而非基础类型使用了归并排序
  为了保证非基础类型的稳定性考虑












